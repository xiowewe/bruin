#### Redis为什么快

1. 基于内存，绝大部分请求是纯粹的内存操作
2. 数据结构简单，对数据操作也简单
3. 采用单线程，避免了不必要的上下文切换和竞争条件
4. 使用多路I/O复用模型，非阻塞IO
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样

##### 数据结构

Redis支持字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet），支撑这些数据类型的底层数据数据结构有6种：简单动态字符串、双向链表、压缩列表、哈希表、跳表、整数数组。

- 全局哈希表

  Redis为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。其实就是一个数组，数组的每个元素称为一个哈希桶。哈希桶中的 entry 元素中保存了*key和*value指针，分别指向了实际的键和值。

- 哈希冲突和rehash

  Redis 解决哈希冲突的方式，就是链式哈希。就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。rehash增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。为了避免大量的数据拷贝造成阻塞，Redis 采用了**渐进式 rehash**

1. 简单动态字符串（String）O(N)

2. 双向链表（List）O(N)

3. 压缩列表（List、Hash、Sorted Set）O(N)

   实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

4. 哈希表（Hash、Set）O(1)

5. 跳表（Sorted Set）O(logN)

6. 整数数组（Set）O(N)

##### 单线程

Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。Redis 6.0 中提出了**多线程模型**

##### 多路复用

多路复用的 Redis IO 模型：Redis 网络框架调用 epoll 机制，让内核监听这些套接字。Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。（具体查看Redis核心技术实战-03）

##### Redis单线程处理IO请求性能瓶颈

1. 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：
   1. 操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；
   2. 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
   3. 大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
   4. 淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
   5. AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
   6. 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

**想法**：

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。



#### 持久化

Redis是内存操作，一旦服务器宕机，内存中的数据将全部丢失。Redis 的持久化主要有两大机制，即 AOF 日志和 RDB 快照。

##### AOF日志

AOF（Append Only File）日志记录的是执行语句，在系统执行成功后才会记录，一方面避免记录错误命令，也不会阻塞当前的写操作。AOF机制依旧存在风险：1、命令执行完还没有来得及记日志就宕机了2、虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险

- AOF写日志策略（appendfsync 配置）

  避免主线程阻塞和减少数据丢失问题，三种策略无法两全齐美，只能在两者之间权衡

  - Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
  - Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
  - No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

- AOF重写机制（auto-aof-rewrite-min-size 10mb 设置日志文件大小）

  为了避免日志文件过大，append命令日志追加效率较低。AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态，从而实现对 某个键值对 重复操作后产生的多条操作记录压缩成一条 的效果。进而实现压缩AOF文件的大小。

- AOF重写避免阻塞

  AOF重写为了避免阻塞主线程，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

  因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样就保证重写日志的齐全

##### 内存快照

